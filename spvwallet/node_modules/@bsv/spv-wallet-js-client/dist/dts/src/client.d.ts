import { AccessKey, AccessKeys, AccessKeyWithSigning, AdminKey, AdminStats, Contact, Contacts, Destination, Destinations, DraftTx, Metadata, PaymailAddress, PaymailAddresses, QueryParams, Recipients, SharedConfig, TransactionConfigInput, Tx, Txs, Utxo, Utxos, XprivWithSigning, XPub, XPubs, XpubWithoutSigning } from './types';
import { Logger, LoggerConfig } from './logger';
import { HttpClient } from './httpclient';
import { HD } from '@bsv/sdk';
import { AccessKeyFilter, ContactFilter, DestinationFilter, AdminPaymailFilter, TransactionFilter, UtxoFilter, XpubFilter, AdminUtxoFilter, AdminAccessKeyFilter } from './filters';
/**
 * SpvWallet class
 *
 * @constructor
 * @example
 * const SpvWalletClient = new SpvWalletClient(<serverUrl>, {
 *   xPriv: <xpriv...>
 * })
 */
export declare class SpvWalletClient {
    logger: Logger;
    http: HttpClient;
    private xPriv?;
    constructor(serverUrl: string, options: XpubWithoutSigning, loggerConfig?: LoggerConfig);
    constructor(serverUrl: string, options: AccessKeyWithSigning, loggerConfig?: LoggerConfig);
    constructor(serverUrl: string, options: XprivWithSigning, loggerConfig?: LoggerConfig);
    constructor(serverUrl: string, options: AdminKey, loggerConfig?: LoggerConfig);
    get xPrivKey(): HD | undefined;
    private makeRequester;
    /**
     * Admin only: Return whether the admin key is valid on the server
     *
     * @return {boolean}
     */
    AdminGetStatus(): Promise<boolean>;
    /**
     * Admin only: Get stats about the SPV Wallet server
     *
     * @return {AdminStats}
     */
    AdminGetStats(): Promise<AdminStats>;
    /**
     * Admin only: Get a list of all access keys in the system, filtered by conditions, metadata and queryParams
     *
     * @param {AdminAccessKeyFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {AccessKeys}
     */
    AdminGetAccessKeys(conditions: AdminAccessKeyFilter, metadata: Metadata, params: QueryParams): Promise<AccessKeys>;
    /**
     * Admin only: Get a count of all access keys in the system, filtered by conditions, metadata and queryParams
     *
     * @param {AdminAccessKeyFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    AdminGetAccessKeysCount(conditions: AdminAccessKeyFilter, metadata: Metadata): Promise<number>;
    /**
     * Admin only: Get a list of all contacts in the system, filtered by conditions, metadata and queryParams
     *
     * @param {ContactFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {Contacts}
     */
    AdminGetContacts(conditions: ContactFilter, metadata: Metadata, params: QueryParams): Promise<Contacts>;
    /**
     * Admin only: Update contact fullName and metadata
     *
     * @param {string} id              Contact ID to update
     * @param {string} fullName        New full name of the contact
     * @param {Metadata} metadata      Key value object to use to filter the documents by the metadata
     * @constructor
     */
    AdminUpdateContact(id: string, fullName: string, metadata: Metadata): Promise<Contact>;
    /**
     * Admin only: Delete a contact
     *
     * @param {string} id Contact ID to delete
     * @return void
     */
    AdminDeleteContact(id: string): Promise<void>;
    /**
     * Admin only: Accept a contact request
     *
     * @param {string} id Contact ID to accept
     * @return {Contact}
     */
    AdminAcceptContact(id: string): Promise<Contact>;
    /**
     * Admin only: Reject a contact request
     *
     * @param {string} id Contact ID to reject
     * @return {Contact}
     */
    AdminRejectContact(id: string): Promise<Contact>;
    /**
     * Admin only: Get a list of all destinations in the system, filtered by conditions, metadata and queryParams
     *
     * @param {DestinationFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {Destinations}
     */
    AdminGetDestinations(conditions: DestinationFilter, metadata: Metadata, params: QueryParams): Promise<Destinations>;
    /**
     * Admin only: Get a count of all destinations in the system, filtered by conditions, metadata and queryParams
     *
     * @param {DestinationFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    AdminGetDestinationsCount(conditions: DestinationFilter, metadata: Metadata): Promise<number>;
    /**
     * Admin only: Get a paymail by address
     *
     * @param address string Paymail address (i.e. alias@example.com)
     * @return {PaymailAddress}
     */
    AdminGetPaymail(address: string): Promise<PaymailAddress>;
    /**
     * Admin only: Get a list of all paymails in the system, filtered by conditions, metadata and queryParams
     *
     * @param {AdminPaymailFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {PaymailAddresses}
     */
    AdminGetPaymails(conditions: AdminPaymailFilter, metadata: Metadata, params: QueryParams): Promise<PaymailAddresses>;
    /**
     * Admin only: Get a count of all paymails in the system, filtered by conditions, metadata and queryParams
     * To get a count of not-deleted paymails, use the condition: { deleted_at: null }
     *
     * @param {AdminPaymailFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    AdminGetPaymailsCount(conditions: AdminPaymailFilter, metadata: Metadata): Promise<number>;
    /**
     * Admin only: Create a new paymail for an xPub
     *
     * @param {string} rawXPub Raw xPub to register the paymail to
     * @param {string} address Paymail address (i.e. alias@example.com)
     * @param {string} public_name Public name for the user to return in Paymail address resolution requests
     * @param {string} avatar Avatar of the user to return in Paymail address resolution requests
     * @return {PaymailAddress}
     */
    AdminCreatePaymail(rawXPub: string, address: string, public_name: string, avatar: string): Promise<PaymailAddress>;
    /**
     * Admin only: Delete a paymail
     *
     * @param address string Paymail address (ie. example@spv-wallet.org)
     * @return void
     */
    AdminDeletePaymail(address: string): Promise<void>;
    /**
     * Admin only: Get a list of all transactions in the system, filtered by conditions, metadata and queryParams
     *
     * @param {TransactionFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {Txs}
     */
    AdminGetTransactions(conditions: TransactionFilter, metadata: Metadata, params: QueryParams): Promise<Txs>;
    /**
     * Admin only: Get a count of all transactions in the system, filtered by conditions, metadata and queryParams
     *
     * @param {TransactionFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    AdminGetTransactionsCount(conditions: TransactionFilter, metadata: Metadata): Promise<number>;
    /**
     * Admin only: Get a list of all utxos in the system, filtered by conditions, metadata and queryParams
     *
     * @param {AdminUtxoFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {Utxos}
     */
    AdminGetUtxos(conditions: AdminUtxoFilter, metadata: Metadata, params: QueryParams): Promise<Utxos>;
    /**
     * Admin only: Get a count of all utxos in the system, filtered by conditions, metadata and queryParams
     *
     * @param {AdminUtxoFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    AdminGetUtxosCount(conditions: AdminUtxoFilter, metadata: Metadata): Promise<number>;
    /**
     * Admin only: Get a list of all xpubs in the system, filtered by conditions, metadata and queryParams
     *
     * @param {XpubFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {XPubs}
     */
    AdminGetXPubs(conditions: XpubFilter, metadata: Metadata, params: QueryParams): Promise<XPubs>;
    /**
     * Admin only: Get a count of all xpubs in the system, filtered by conditions, metadata and queryParams
     *
     * @param {XpubFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    AdminGetXPubsCount(conditions: XpubFilter, metadata: Metadata): Promise<number>;
    /**
     * Admin only: Register a new xPub into the SPV Wallet
     *
     * @param {string} rawXPub    XPub string
     * @param {Metadata} metadata Key value object to use to add to the xpub
     * @return {XPub}             The newly registered xpub
     */
    AdminNewXpub(rawXPub: string, metadata: Metadata): Promise<XPub>;
    /**
     * Admin only: Record a transaction without any of the normal checks
     *
     * @param {string} hex  Hex string of the transaction
     * @return {Tx}
     */
    AdminRecordTransaction(hex: string): Promise<Tx>;
    /**
     * Get information about the xpub from the server of the current user
     *
     * @return {XPub}
     */
    GetXPub(): Promise<XPub>;
    /**
     * Update the metadata of the xpub of the current user
     *
     * Admin key should be set to use this method
     *
     * @param {Metadata} metadata Key value object to use to update the metadata. To delete keys add a key with null value
     * @return {XPub}
     */
    UpdateXPubMetadata(metadata: Metadata): Promise<XPub>;
    /**
     * Get an access key by ID
     *
     * @param {string} id The database ID of the access key
     * @return {AccessKey}
     */
    GetAccessKey(id: string): Promise<AccessKey>;
    /**
     * Get a list of all access keys for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {AccessKeyFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} queryParams Database query parameters for page, page size and sorting
     * @return {AccessKeys}
     */
    GetAccessKeys(conditions: AccessKeyFilter, metadata: Metadata, queryParams: QueryParams): Promise<AccessKeys>;
    /**
     * Get a count of all access keys for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {AccessKeyFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    GetAccessKeysCount(conditions: AccessKeyFilter, metadata: Metadata): Promise<number>;
    /**
     * Create a new access key, with the (optional) metadata
     *
     * This method returns the newly created access key, with the private key, which is only given out this once
     *
     * @param metadata Metadata Metadata to add to the new access key
     * @return {AccessKey}
     */
    CreateAccessKey(metadata: Metadata): Promise<AccessKey>;
    /**
     * Revoke an access key and invalidate in the database
     *
     * After this function is successfully called, the access key cannot be used anymore on an SPV Wallet server
     *
     * @param id string The database ID of the access key to revoke
     * @return {AccessKey}
     */
    RevokeAccessKey(id: string): Promise<AccessKey>;
    /**
     * Get a destination of the current user by database ID
     *
     * @param id string Database ID of destination (sha256 hash of locking script)
     * @return {Destination}
     */
    GetDestinationByID(id: string): Promise<Destination>;
    /**
     * Get a destination of the current user by locking script
     *
     * @param locking_script string Locking script (script pub key)
     * @return {Destination}
     */
    GetDestinationByLockingScript(locking_script: string): Promise<Destination>;
    /**
     * Get a destination of the current user by bitcoin address
     *
     * @param address string Bitcoin address
     * @return {Destination}
     */
    GetDestinationByAddress(address: string): Promise<Destination>;
    /**
     * Get a list of all destinations for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {DestinationFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} queryParams Database query parameters for page, page size and sorting
     * @return {Destinations}
     */
    GetDestinations(conditions: DestinationFilter, metadata: Metadata, queryParams: QueryParams): Promise<Destinations>;
    /**
     * Get a count of all destinations for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {DestinationFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    GetDestinationsCount(conditions: DestinationFilter, metadata: Metadata): Promise<number>;
    /**
     * Create a new destination to receive bsv with and return that destination
     *
     * This function allows you to create a destination that will be monitored on-chain and will import any transactions
     * related to that destination into SPV Wallet. This is legacy functionality in Bitcoin and should only be used if a p2p
     * option (paymail) is not possible. Use sparingly.
     *
     * @param {Metadata} metadata Key value object to attach to the new destination
     * @return {Destination}
     */
    NewDestination(metadata: Metadata): Promise<Destination>;
    /**
     * Updated the metadata object of the destination given by ID with new keys (does not overwrite the old object)
     *
     * To remove a key from the metadata object, add a key to set with a value of `null`
     *
     * @param {string} id Database ID of the destination
     * @param {Metadata} metadata Key value object to append to the metadata of the destination
     * @return {Destination}
     */
    UpdateDestinationMetadataByID(id: string, metadata: Metadata): Promise<Destination>;
    /**
     * Updated the metadata object of the destination given by locking script with new keys (does not overwrite the old object)
     *
     * To remove a key from the metadata object, add a key to set with a value of `null`
     *
     * @param {string} locking_script Locking script of the destination
     * @param {Metadata} metadata Key value object to append to the metadata of the destination
     * @return {Destination}
     */
    UpdateDestinationMetadataByLockingScript(locking_script: string, metadata: Metadata): Promise<Destination>;
    /**
     * Updated the metadata object of the destination given by address with new keys (does not overwrite the old object)
     *
     * To remove a key from the metadata object, add a key to set with a value of `null`
     *
     * @param {string} address Address of the destination
     * @param {Metadata} metadata Key value object to append to the metadata of the destination
     * @return {Destination}
     */
    UpdateDestinationMetadataByAddress(address: string, metadata: Metadata): Promise<Destination>;
    /**
     * Get a list of all contacts for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {ContactFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} queryParams Database query parameters for page, page size and sorting
     * @return {Contacts}
     */
    GetContacts(conditions: ContactFilter, metadata: Metadata, queryParams: QueryParams): Promise<Contacts>;
    /**
     * Upsert will add a new contact or modify an existing one.
     *
     * @param {string} paymail            Contact paymail to add or modify
     * @param {string} fullName           Full name of the contact which could be shown instead of whole paymail address.
     * @param {string} requesterPaymail   Paymail of the requester
     * @param {Metadata} metadata         Key value object to use to filter the documents by the metadata
     * @return {Contact}
     */
    UpsertContact(paymail: string, fullName: string, requesterPaymail: string, metadata: Metadata): Promise<Contact>;
    /**
     * Accept a contact request
     *
     * @param {string} paymail Contact paymail to modify
     * @return {void}
     */
    AcceptContact(paymail: string): Promise<void>;
    /**
     * Reject a contact request
     *
     * @param {string} paymail Contact paymail to modify
     * @return {void}
     */
    RejectContact(paymail: string): Promise<void>;
    /**
     * Confirm a contact request
     *
     * @param {string} passcode - The passcode for the contact
     * @param contact
     * @param {string} paymail Contact paymail
     * @param {number} period - The period for the TOTP
     * @param {number} digits - The number of digits for the TOTP
     * @returns {Promise<void>}
     * @throws {ErrorWrongTOTP} If the TOTP is invalid
     * @throws {ErrorNoXPrivToValidateTOTP} If the xPriv is not set
     */
    ConfirmContact(passcode: string, contact: Contact, paymail: string, period: number, digits: number): Promise<boolean>;
    /**
     * Get all details of the transaction by the given ID
     *
     * @param {string} txID Transaction ID
     * @return {Tx}
     */
    GetTransaction(txID: string): Promise<Tx>;
    /**
     * Get a list of all transactions for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {TransactionFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} queryParams Database query parameters for page, page size and sorting
     * @return {Txs}
     */
    GetTransactions(conditions: TransactionFilter, metadata: Metadata, queryParams: QueryParams): Promise<Txs>;
    /**
     * Get a count of all transactions for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {TransactionFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    GetTransactionsCount(conditions: TransactionFilter, metadata: Metadata): Promise<number>;
    /**
     * Get all details of the utxo by the given ID
     *
     * @param {string} tx_id Transaction ID of the UTXO
     * @param {number} output_index Index of output within the transaction of the UTXO
     * @return {Utxo}
     */
    GetUtxo(tx_id: string, output_index: number): Promise<Utxo>;
    /**
     * Get a list of all utxos for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {UtxoFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} queryParams Database query parameters for page, page size and sorting
     * @return {Utxos}
     */
    GetUtxos(conditions: UtxoFilter, metadata: Metadata, queryParams: QueryParams): Promise<Utxos>;
    /**
     * Get a count of all utxos for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {UtxoFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    GetUtxosCount(conditions: UtxoFilter, metadata: Metadata): Promise<number>;
    /**
     * Create a draft transaction to the recipients given
     *
     * This is a helper function to easily create a new draft transaction to a list of recipients
     *
     * @see {@link SendToRecipients}
     * @param {Recipients} recipients A list of recipients and a satoshi value to send to them
     * @param {Metadata} metadata     Key value object to use to add to the draft transaction
     * @return {DraftTx}     Complete draft transaction object from SPV Wallet, all configuration options filled in
     */
    DraftToRecipients(recipients: Recipients, metadata: Metadata): Promise<DraftTx>;
    /**
     * Create a draft transaction using the given transaction config
     *
     * @param {TransactionConfigInput} transactionConfig Configuration of the new transaction
     * @param {Metadata} metadata                        Key value object to use to add to the draft transaction
     * @return {DraftTx}                        Complete draft transaction object from SPV Wallet, all configuration options filled in
     */
    DraftTransaction(transactionConfig: TransactionConfigInput, metadata: Metadata): Promise<DraftTx>;
    /**
     * Helper function to create a draft, sign it and send it to a list of recipients
     *
     * @param {Recipients} recipients A list of recipients and a satoshi value to send to them
     * @param {Metadata} metadata     Key value object to use to add to the (draft) transaction
     * @return {Tx}          The final transaction object, including the hex of the Bitcoin transaction
     * @example
     * // This function is a shorthand for:
     * const draft = await spvWalletClient.DraftToRecipients(recipients, metadata);
     * const finalized = await spvWalletClient.SignTransaction(draft);
     * const tx = await spvWalletClient.RecordTransaction(finalized, draft.id, metadata)
     */
    SendToRecipients(recipients: Recipients, metadata: Metadata): Promise<Tx>;
    /**
     * Finalize and sign the given draft transaction
     *
     * @param {DraftTx} draftTransaction Draft transaction object
     * @return {string} Final transaction hex
     */
    SignTransaction(draftTransaction: DraftTx): Promise<string>;
    /**
     * Record a Bitcoin transaction (in hex) into SPV Wallet
     *
     * This will only work of an input or output of the transaction can be related to an SPV Wallet user. SPV Wallet does not record
     * unrelated transaction into its database.
     *
     * @param {string} hex         Hex string of the Bitcoin transaction
     * @param {string} referenceID Optional reference ID (draft transaction ID)
     * @param {Metadata} metadata  Key value object to use to add to the transaction
     * @return {Tx}       The SPV Wallet transaction object
     */
    RecordTransaction(hex: string, referenceID: string, metadata: Metadata): Promise<Tx>;
    /**
     * Updated the metadata object of the transaction given by txID with new keys (does not overwrite the old object)
     *
     * To remove a key from the metadata object, add a key to set with a value of `null`
     *
     * @param {string} txID       The ID of the transaction
     * @param {Metadata} metadata Key value object to use to add to the transaction
     * @return {Tx}      The complete SPV Wallet transaction object, with the new changes
     */
    UpdateTransactionMetadata(txID: string, metadata: Metadata): Promise<Tx>;
    /**
     * Retrieves the shared configuration from the server.
     * @returns {SharedConfig} A promise that resolves to the shared configuration.
     */
    GetSharedConfig(): Promise<SharedConfig>;
    /**
     * Generates a TOTP for a given contact
     *
     * @param contact - The Contact
     * @param period - The TOTP period (default: 30)
     * @param digits - The number of TOTP digits (default: 2)
     * @returns The generated TOTP as a string
     */
    GenerateTotpForContact(contact: Contact, period?: number, digits?: number): string;
    /**
     * Validates a TOTP for a given contact
     *
     * @param passcode - The TOTP passcode to validate
     * @param requesterPaymail - The paymail of the requester
     * @param period - The TOTP period (default: 30)
     * @param digits - The number of TOTP digits (default: 2)
     * @returns A boolean indicating whether the TOTP is valid
     * @throws {ErrorNoXPrivToValidateTOTP} If the xPrivKey is not set
     */
    ValidateTotpForContact(contact: Contact, passcode: string, requesterPaymail: string, period?: number, digits?: number): boolean;
}
