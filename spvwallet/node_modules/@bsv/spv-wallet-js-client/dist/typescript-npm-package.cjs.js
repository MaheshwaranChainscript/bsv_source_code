'use strict';

require('cross-fetch/polyfill');
var sdk = require('@bsv/sdk');
var tslib = require('tslib');

class SpvWalletError extends Error {
    constructor(message) {
        super(message);
        this.name = this.constructor.name;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
}
class ErrorInvalidOptions extends SpvWalletError {
    constructor(logger, options) {
        super('Invalid options. None of xPub, xPriv, accessKey nor adminKey is set');
        logger.debug('Invalid options: ', options);
    }
}
class ErrorNoXPrivToSignTransaction extends SpvWalletError {
    constructor() {
        super('Cannot sign transaction without an xPriv');
    }
}
class ErrorClientInitNoXpriv extends SpvWalletError {
    constructor() {
        super('Init client with xPriv first');
    }
}
class ErrorTxIdsDontMatchToDraft extends SpvWalletError {
    constructor(logger, input, index, draftInput) {
        super('Input tx ids do not match in draft and transaction hex');
        logger.debug('The input: ', input, 'Tx index: ', index, 'The draft', draftInput);
        this.input = input;
        this.draftInput = draftInput;
    }
}
class ErrorNoAdminKey extends SpvWalletError {
    constructor() {
        super('Admin key has not been set. Cannot do admin queries.');
    }
}
class ErrorResponse extends SpvWalletError {
    constructor(logger, response, content) {
        super('Received error response');
        logger.debug('StatusCode:', response.status, 'Error response:', response, 'The content:', content);
        this.response = response;
        this.content = content;
    }
}
class ErrorWrongHex extends SpvWalletError {
    constructor(wrongHex) {
        super('Provided hexHash is not a valid hex string');
        this.value = wrongHex;
    }
}
class ErrorNoXPrivToGenerateTOTP extends SpvWalletError {
    constructor() {
        super('Cannot generate TOTP without an xPrivKey set');
    }
}
class ErrorNoXPrivToValidateTOTP extends SpvWalletError {
    constructor() {
        super('Cannot validate TOTP without an xPrivKey set');
    }
}
class ErrorWrongTOTP extends SpvWalletError {
    constructor() {
        super('TOTP is invalid');
    }
}

const maxInt32 = 2147483648 - 1; // 0x80000000
// RandomHex returns a random hex string and error
const RandomHex = function (n) {
    return sdk.Utils.toHex(sdk.Random(n));
};
// ToHash returns a sha256 hash of the string
const ToHash = function (string) {
    const sha256 = sdk.Hash.sha256(string);
    return sdk.Utils.toHex(sha256);
};
// isHex returns whether the given hex string a valid hex string is
const isHex = function (hexString) {
    return !!hexString.match(/^[0-9a-f]*$/i);
};
// getChildNumsFromHex get an array of numbers from the hex string
const getChildNumsFromHex = function (hexHash) {
    if (!isHex(hexHash)) {
        throw new ErrorWrongHex(hexHash);
    }
    const strLen = hexHash.length;
    const size = 8;
    const splitLength = Math.ceil(strLen / size);
    const childNums = [];
    for (let i = 0; i < splitLength; i++) {
        const start = i * size;
        let stop = start + size;
        if (stop > strLen) {
            stop = strLen;
        }
        let num = Number('0x' + hexHash.substring(start, stop));
        if (num > maxInt32) {
            num = num - maxInt32;
        }
        childNums.push(num);
    }
    return childNums;
};

// deriveChildKeyFromHex derive the child extended key from the hex string
const deriveChildKeyFromHex = function (hdKey, hexHash) {
    return deriveHDChildKeyFromHex(hdKey, hexHash);
};
const deriveHDChildKeyFromHex = function (hdKey, hexHash) {
    let childKey = hdKey;
    const childNums = getChildNumsFromHex(hexHash);
    childNums.forEach((childNum) => {
        childKey = childKey.deriveChild(childNum);
    });
    return childKey;
};
const generateKeys = function () {
    const mnemonic = sdk.Mnemonic.fromRandom();
    return getKeysFromMnemonic(mnemonic.toString());
};
const getKeysFromMnemonic = function (mnemonicStr) {
    const mnemonic = sdk.Mnemonic.fromString(mnemonicStr);
    const seed = mnemonic.toSeed();
    const hdWallet = new sdk.HD().fromSeed(seed);
    return {
        xPriv: () => hdWallet.toString(),
        mnemonic: mnemonic.toString(),
        xPub: {
            toString() {
                return hdWallet.toPublic().toString();
            },
        },
    };
};
const getKeysFromString = function (privateKey) {
    let hdWallet = new sdk.HD().fromString(privateKey);
    return {
        xPriv: () => hdWallet.privKey.toString(),
        xPub: {
            toString() {
                return hdWallet.toPublic().toString();
            },
        },
    };
};

const isLogger = (loggerConfig) => {
    const logger = loggerConfig;
    return (typeof logger.debug === 'function' &&
        typeof logger.info === 'function' &&
        typeof logger.warn === 'function' &&
        typeof logger.error === 'function');
};
const nop = () => { };
const defaultLogger = { level: 'info' };
const levelToNumber = (level) => {
    switch (level) {
        case 'debug':
            return 1;
        case 'info':
            return 2;
        case 'warn':
            return 3;
        case 'error':
            return 4;
        case 'disabled':
            return 5;
        default:
            return 2;
    }
};
const makeLogger = (loggerConfig) => {
    if (isLogger(loggerConfig)) {
        return loggerConfig;
    }
    else {
        const { level } = loggerConfig;
        const levelAsNumber = levelToNumber(level);
        return {
            debug: levelAsNumber <= 1 ? console.debug : nop,
            info: levelAsNumber <= 2 ? console.info : nop,
            warn: levelAsNumber <= 3 ? console.warn : nop,
            error: levelAsNumber <= 4 ? console.error : nop,
        };
    }
};

const signMessage = function (message, privateKey) {
    const messageBuf = sdk.Utils.toArray(message);
    const hash = sdk.BSM.magicHash(messageBuf);
    const bnh = new sdk.BigNumber(hash);
    const signature = sdk.ECDSA.sign(bnh, privateKey, true);
    const recovery = signature.CalculateRecoveryFactor(privateKey.toPublicKey(), bnh);
    return signature.toCompact(recovery, true, 'base64');
};

// AuthHeader is the header to use for authentication (raw xPub)
const AuthHeader = 'x-auth-xpub';
// AuthAccessKey is the header to use for access key authentication (access public key)
const AuthAccessKey = 'x-auth-key';
// AuthSignature is the given signature (body + timestamp)
const AuthSignature = 'x-auth-signature';
// AuthHeaderHash hash of the body coming from the request
const AuthHeaderHash = 'x-auth-hash';
// AuthHeaderNonce random nonce for the request
const AuthHeaderNonce = 'x-auth-nonce';
// AuthHeaderTime the time of the request, only valid for 30 seconds
const AuthHeaderTime = 'x-auth-time';
const setSignature = function (headers, signingKey, bodyString) {
    // Create the signature
    const authData = createSignature(signingKey, bodyString);
    // Set the auth header
    if (authData.xPub) {
        headers[AuthHeader] = authData.xPub;
    }
    else if (authData.accessKey) {
        headers[AuthAccessKey] = authData.accessKey;
    }
    return setSignatureHeaders(headers, authData);
};
const setSignatureHeaders = function (headers, authData) {
    // Create the auth header hash
    if (authData.AuthHash) {
        headers[AuthHeaderHash] = authData.AuthHash;
    }
    // Set the nonce
    if (authData.AuthNonce) {
        headers[AuthHeaderNonce] = authData.AuthNonce;
    }
    // Set the time
    if (authData.AuthTime) {
        headers[AuthHeaderTime] = authData.AuthTime.toString();
    }
    // Set the signature
    if (authData.Signature) {
        headers[AuthSignature] = authData.Signature;
    }
    return headers;
};
const createSignature = function (signingKey, bodyString) {
    const payload = {};
    // x-auth-nonce is a random unique string to seed the signing message
    // this can be checked server side to make sure the request is not being replayed
    payload.AuthNonce = RandomHex(32);
    let privateKey;
    if (isHDWallet(signingKey)) {
        // Get the xPub
        payload.xPub = signingKey.toPublic().toString();
        payload.accessKey = undefined;
        // Derive the address for signing
        const hdWallet = deriveHDChildKeyFromHex(signingKey, payload.AuthNonce);
        privateKey = hdWallet.privKey;
    }
    else {
        privateKey = signingKey;
        payload.xPub = undefined;
        payload.accessKey = privateKey.toPublicKey().toString();
    }
    return createSignatureCommon(payload, bodyString, privateKey);
};
const createSignatureCommon = function (payload, bodyString, privateKey) {
    // Create the auth header hash
    payload.AuthHash = ToHash(bodyString);
    // x-auth-time is the current time and makes sure a request can not be sent after 30 secs
    payload.AuthTime = +new Date();
    let key = payload.xPub;
    if (!key && payload.accessKey) {
        key = payload.accessKey;
    }
    // Signature, using bitcoin signMessage
    const message = getSigningMessage(key || '', payload);
    payload.Signature = signMessage(message, privateKey);
    return payload;
};
// getSigningMessage will build the signing message string
const getSigningMessage = function (xPub, auth) {
    return `${xPub}${auth.AuthHash}${auth.AuthNonce}${auth.AuthTime}`;
};
const isHDWallet = (key) => {
    return key != null && key instanceof sdk.HD;
};

class HttpClient {
    constructor(logger, url, key, adminKey) {
        if (key != null) {
            if (typeof key === 'string') {
                //only xPub can be a string
                this.xPubString = key;
            }
            else {
                this.signingKey = key;
            }
        }
        if (adminKey) {
            this.adminKey = new sdk.HD().fromString(adminKey);
        }
        this.logger = logger;
        this.baseUrl = url.endsWith('/') ? url : url + '/'; //make sure the url ends with a '/'
    }
    adminRequest(path_1) {
        return tslib.__awaiter(this, arguments, void 0, function* (path, method = 'GET', payload = null) {
            if (!this.hasAdminKey()) {
                throw new ErrorNoAdminKey();
            }
            this.logger.debug('Making request as admin on', method, path);
            return this.makeRequest(path, method, payload, this.adminKey);
        });
    }
    request(path_1) {
        return tslib.__awaiter(this, arguments, void 0, function* (path, method = 'GET', payload = null) {
            this.logger.debug('Making request on', method, path);
            return this.makeRequest(path, method, payload, this.signingKey);
        });
    }
    hasAdminKey() {
        return this.adminKey != null;
    }
    makeRequest(path, method, payload, currentSigningKey) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const json = payload ? JSON.stringify(payload) : null;
            let headers = { 'content-type': 'application/json' };
            if (currentSigningKey != null) {
                headers = setSignature(headers, currentSigningKey, json || '');
            }
            else if (this.xPubString) {
                headers[AuthHeader] = this.xPubString;
            }
            const res = yield globalThis.fetch(this.prepareUrl(path), {
                method,
                headers,
                body: json,
            });
            if (res.ok) {
                const contentType = res.headers.get('Content-Type');
                if (contentType && contentType.includes('application/json')) {
                    return res.json();
                }
                return res.text();
            }
            else {
                const rawContent = yield res.text();
                throw new ErrorResponse(this.logger, res, rawContent);
            }
        });
    }
    prepareUrl(path) {
        path = path.startsWith('/') ? path.substring(1) : path;
        return this.baseUrl + path;
    }
}

const DEFAULT_TOTP_PERIOD = 30;
const DEFAULT_TOTP_DIGITS = 2;
/*
Basic flow:
Alice generates passcodeForBob with (sharedSecret+(contact.Paymail as bobPaymail))
Alice sends passcodeForBob to Bob (e.g. via email)
Bob validates passcodeForBob with (sharedSecret+(requesterPaymail as bobPaymail))
The (sharedSecret+paymail) is a "directedSecret". This ensures that passcodeForBob-from-Alice != passcodeForAlice-from-Bob.
The flow looks the same for Bob generating passcodeForAlice.
*/
/**
 * Generates a TOTP for a given contact
 *
 * @param clientXPriv - The client xpriv
 * @param contact - The Contact
 * @param period - The TOTP period (default: 30)
 * @param digits - The number of TOTP digits (default: 2)
 * @returns The generated TOTP as a string
 */
const generateTotpForContact = (clientXPriv, contact, period = DEFAULT_TOTP_PERIOD, digits = DEFAULT_TOTP_DIGITS) => {
    const sharedSecret = makeSharedSecret(contact, clientXPriv);
    let secret = directedSecret(sharedSecret, contact.paymail);
    return sdk.TOTP.generate(secret, getTotpOps(period, digits));
};
/**
 * Validates a TOTP for a given contact
 *
 * @param clientXPriv - The client xpriv
 * @param contact - The Contact
 * @param passcode - The TOTP passcode to validate
 * @param requesterPaymail - The paymail of the requester
 * @param period - The TOTP period (default: 30)
 * @param digits - The number of TOTP digits (default: 2)
 * @returns A boolean indicating whether the TOTP is valid
 */
const validateTotpForContact = (clientXPriv, contact, passcode, requesterPaymail, period = DEFAULT_TOTP_PERIOD, digits = DEFAULT_TOTP_DIGITS) => {
    const sharedSecret = makeSharedSecret(contact, clientXPriv);
    const secret = directedSecret(sharedSecret, requesterPaymail);
    return sdk.TOTP.validate(secret, passcode, getTotpOps(period, digits));
};
const getTotpOps = (period, digits) => ({
    digits,
    period,
    algorithm: 'SHA-1',
});
const makeSharedSecret = (contact, clientXPriv) => {
    const xprivKey = new sdk.HD().fromString(clientXPriv.toString());
    const pubKey = sdk.PublicKey.fromString(contact.pubKey);
    // PKI derivation path: m/0/0/0
    // NOTICE: we currently do not support PKI rotation; however, adjustments will be made if and when we decide to implement it
    const hd = xprivKey.derive('m/0/0/0');
    const privKey = hd.privKey;
    const ss = privKey.deriveSharedSecret(pubKey);
    return ss.getX().toHex(32);
};
const directedSecret = (sharedSecret, paymail) => {
    const sharedSecretDigest = sdk.Utils.toArray(sharedSecret, 'hex');
    const paymailDigest = sdk.Utils.toArray(paymail, 'utf8');
    const concatenated = [...sharedSecretDigest, ...paymailDigest];
    return concatenated;
};

/**
 * SpvWallet class
 *
 * @constructor
 * @example
 * const SpvWalletClient = new SpvWalletClient(<serverUrl>, {
 *   xPriv: <xpriv...>
 * })
 */
class SpvWalletClient {
    constructor(serverUrl, options, loggerConfig = defaultLogger) {
        this.logger = makeLogger(loggerConfig);
        this.http = this.makeRequester(options, serverUrl);
    }
    get xPrivKey() {
        return this.xPriv;
    }
    makeRequester(options, serverUrl) {
        if (options.adminKey) {
            this.logger.info('Using adminKey to sign admin requests');
        }
        if ('xPub' in options) {
            this.logger.info('Using XPub. SendToRecipients function will not be available.');
            return new HttpClient(this.logger, serverUrl, options.xPub, options.adminKey);
        }
        if ('xPriv' in options) {
            this.logger.info('Using xPriv to sign requests');
            this.xPriv = new sdk.HD().fromString(options.xPriv);
            return new HttpClient(this.logger, serverUrl, this.xPriv, options.adminKey);
        }
        if ('accessKey' in options) {
            this.logger.info('Using accessKey to sign requests. SendToRecipients will not be available.');
            const signingKey = sdk.PrivateKey.fromString(options.accessKey, 'hex');
            return new HttpClient(this.logger, serverUrl, signingKey, options.adminKey);
        }
        if (options.adminKey != null) {
            this.logger.warn('Non-admin requests will not work because xPub, xPriv nor accessKey is provided.');
            return new HttpClient(this.logger, serverUrl, undefined, options.adminKey);
        }
        throw new ErrorInvalidOptions(this.logger, options);
    }
    /**
     * Admin only: Return whether the admin key is valid on the server
     *
     * @return {boolean}
     */
    AdminGetStatus() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/status`);
        });
    }
    /**
     * Admin only: Get stats about the SPV Wallet server
     *
     * @return {AdminStats}
     */
    AdminGetStats() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/stats`);
        });
    }
    /**
     * Admin only: Get a list of all access keys in the system, filtered by conditions, metadata and queryParams
     *
     * @param {AdminAccessKeyFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {AccessKeys}
     */
    AdminGetAccessKeys(conditions, metadata, params) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/access-keys/search`, 'POST', {
                conditions,
                metadata,
                params,
            });
        });
    }
    /**
     * Admin only: Get a count of all access keys in the system, filtered by conditions, metadata and queryParams
     *
     * @param {AdminAccessKeyFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    AdminGetAccessKeysCount(conditions, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/access-keys/count`, 'POST', {
                conditions,
                metadata,
            });
        });
    }
    /**
     * Admin only: Get a list of all contacts in the system, filtered by conditions, metadata and queryParams
     *
     * @param {ContactFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {Contacts}
     */
    AdminGetContacts(conditions, metadata, params) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/contact/search`, 'POST', {
                conditions,
                metadata,
                params,
            });
        });
    }
    /**
     * Admin only: Update contact fullName and metadata
     *
     * @param {string} id              Contact ID to update
     * @param {string} fullName        New full name of the contact
     * @param {Metadata} metadata      Key value object to use to filter the documents by the metadata
     * @constructor
     */
    AdminUpdateContact(id, fullName, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/contact/${id}`, 'PATCH', { fullName, metadata });
        });
    }
    /**
     * Admin only: Delete a contact
     *
     * @param {string} id Contact ID to delete
     * @return void
     */
    AdminDeleteContact(id) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            yield this.http.adminRequest(`admin/contact/${id}`, 'DELETE', {});
        });
    }
    /**
     * Admin only: Accept a contact request
     *
     * @param {string} id Contact ID to accept
     * @return {Contact}
     */
    AdminAcceptContact(id) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/contact/accepted/${id}`, 'PATCH', {});
        });
    }
    /**
     * Admin only: Reject a contact request
     *
     * @param {string} id Contact ID to reject
     * @return {Contact}
     */
    AdminRejectContact(id) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/contact/rejected/${id}`, 'PATCH', {});
        });
    }
    /**
     * Admin only: Get a list of all destinations in the system, filtered by conditions, metadata and queryParams
     *
     * @param {DestinationFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {Destinations}
     */
    AdminGetDestinations(conditions, metadata, params) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/destinations/search`, 'POST', {
                conditions,
                metadata,
                params,
            });
        });
    }
    /**
     * Admin only: Get a count of all destinations in the system, filtered by conditions, metadata and queryParams
     *
     * @param {DestinationFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    AdminGetDestinationsCount(conditions, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/destinations/count`, 'POST', {
                conditions,
                metadata,
            });
        });
    }
    /**
     * Admin only: Get a paymail by address
     *
     * @param address string Paymail address (i.e. alias@example.com)
     * @return {PaymailAddress}
     */
    AdminGetPaymail(address) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/paymail/get`, 'POST', { address });
        });
    }
    /**
     * Admin only: Get a list of all paymails in the system, filtered by conditions, metadata and queryParams
     *
     * @param {AdminPaymailFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {PaymailAddresses}
     */
    AdminGetPaymails(conditions, metadata, params) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/paymails/search`, 'POST', {
                conditions,
                metadata,
                params,
            });
        });
    }
    /**
     * Admin only: Get a count of all paymails in the system, filtered by conditions, metadata and queryParams
     * To get a count of not-deleted paymails, use the condition: { deleted_at: null }
     *
     * @param {AdminPaymailFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    AdminGetPaymailsCount(conditions, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/paymails/count`, 'POST', {
                conditions,
                metadata,
            });
        });
    }
    /**
     * Admin only: Create a new paymail for an xPub
     *
     * @param {string} rawXPub Raw xPub to register the paymail to
     * @param {string} address Paymail address (i.e. alias@example.com)
     * @param {string} public_name Public name for the user to return in Paymail address resolution requests
     * @param {string} avatar Avatar of the user to return in Paymail address resolution requests
     * @return {PaymailAddress}
     */
    AdminCreatePaymail(rawXPub, address, public_name, avatar) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/paymail/create`, 'POST', {
                key: rawXPub,
                address,
                public_name,
                avatar,
            });
        });
    }
    /**
     * Admin only: Delete a paymail
     *
     * @param address string Paymail address (ie. example@spv-wallet.org)
     * @return void
     */
    AdminDeletePaymail(address) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            yield this.http.adminRequest(`admin/paymail/delete`, 'DELETE', { address });
        });
    }
    /**
     * Admin only: Get a list of all transactions in the system, filtered by conditions, metadata and queryParams
     *
     * @param {TransactionFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {Txs}
     */
    AdminGetTransactions(conditions, metadata, params) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/transactions/search`, 'POST', {
                conditions,
                metadata,
                params,
            });
        });
    }
    /**
     * Admin only: Get a count of all transactions in the system, filtered by conditions, metadata and queryParams
     *
     * @param {TransactionFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    AdminGetTransactionsCount(conditions, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/transactions/count`, 'POST', {
                conditions,
                metadata,
            });
        });
    }
    /**
     * Admin only: Get a list of all utxos in the system, filtered by conditions, metadata and queryParams
     *
     * @param {AdminUtxoFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {Utxos}
     */
    AdminGetUtxos(conditions, metadata, params) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/utxos/search`, 'POST', {
                conditions,
                metadata,
                params,
            });
        });
    }
    /**
     * Admin only: Get a count of all utxos in the system, filtered by conditions, metadata and queryParams
     *
     * @param {AdminUtxoFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    AdminGetUtxosCount(conditions, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/utxos/count`, 'POST', {
                conditions,
                metadata,
            });
        });
    }
    /**
     * Admin only: Get a list of all xpubs in the system, filtered by conditions, metadata and queryParams
     *
     * @param {XpubFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {XPubs}
     */
    AdminGetXPubs(conditions, metadata, params) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/xpubs/search`, 'POST', {
                conditions,
                metadata,
                params,
            });
        });
    }
    /**
     * Admin only: Get a count of all xpubs in the system, filtered by conditions, metadata and queryParams
     *
     * @param {XpubFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    AdminGetXPubsCount(conditions, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/xpubs/count`, 'POST', {
                conditions,
                metadata,
            });
        });
    }
    /**
     * Admin only: Register a new xPub into the SPV Wallet
     *
     * @param {string} rawXPub    XPub string
     * @param {Metadata} metadata Key value object to use to add to the xpub
     * @return {XPub}             The newly registered xpub
     */
    AdminNewXpub(rawXPub, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/xpub`, 'POST', {
                key: rawXPub,
                metadata,
            });
        });
    }
    /**
     * Admin only: Record a transaction without any of the normal checks
     *
     * @param {string} hex  Hex string of the transaction
     * @return {Tx}
     */
    AdminRecordTransaction(hex) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.adminRequest(`admin/transactions/record`, 'POST', { hex });
        });
    }
    /**
     * Get information about the xpub from the server of the current user
     *
     * @return {XPub}
     */
    GetXPub() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`xpub`);
        });
    }
    /**
     * Update the metadata of the xpub of the current user
     *
     * Admin key should be set to use this method
     *
     * @param {Metadata} metadata Key value object to use to update the metadata. To delete keys add a key with null value
     * @return {XPub}
     */
    UpdateXPubMetadata(metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`xpub`, 'PATCH', { metadata });
        });
    }
    /**
     * Get an access key by ID
     *
     * @param {string} id The database ID of the access key
     * @return {AccessKey}
     */
    GetAccessKey(id) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`access-key?id=${id}`);
        });
    }
    /**
     * Get a list of all access keys for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {AccessKeyFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} queryParams Database query parameters for page, page size and sorting
     * @return {AccessKeys}
     */
    GetAccessKeys(conditions, metadata, queryParams) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`access-key/search`, 'POST', {
                conditions,
                metadata,
                page: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.page) || 0,
                page_size: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.page_size) || 0,
                order_by_field: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.order_by_field) || '',
                sort_direction: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.sort_direction) || '',
            });
        });
    }
    /**
     * Get a count of all access keys for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {AccessKeyFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    GetAccessKeysCount(conditions, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`access-key/count`, 'POST', {
                conditions,
                metadata,
            });
        });
    }
    /**
     * Create a new access key, with the (optional) metadata
     *
     * This method returns the newly created access key, with the private key, which is only given out this once
     *
     * @param metadata Metadata Metadata to add to the new access key
     * @return {AccessKey}
     */
    CreateAccessKey(metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`access-key`, 'POST', { metadata });
        });
    }
    /**
     * Revoke an access key and invalidate in the database
     *
     * After this function is successfully called, the access key cannot be used anymore on an SPV Wallet server
     *
     * @param id string The database ID of the access key to revoke
     * @return {AccessKey}
     */
    RevokeAccessKey(id) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`access-key?id=${id}`, 'DELETE');
        });
    }
    /**
     * Get a destination of the current user by database ID
     *
     * @param id string Database ID of destination (sha256 hash of locking script)
     * @return {Destination}
     */
    GetDestinationByID(id) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`destination?id=${id}`);
        });
    }
    /**
     * Get a destination of the current user by locking script
     *
     * @param locking_script string Locking script (script pub key)
     * @return {Destination}
     */
    GetDestinationByLockingScript(locking_script) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`destination?locking_script=${locking_script}`);
        });
    }
    /**
     * Get a destination of the current user by bitcoin address
     *
     * @param address string Bitcoin address
     * @return {Destination}
     */
    GetDestinationByAddress(address) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`destination?address=${address}`);
        });
    }
    /**
     * Get a list of all destinations for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {DestinationFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} queryParams Database query parameters for page, page size and sorting
     * @return {Destinations}
     */
    GetDestinations(conditions, metadata, queryParams) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`destination/search`, 'POST', {
                conditions,
                metadata,
                page: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.page) || 0,
                page_size: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.page_size) || 0,
                order_by_field: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.order_by_field) || '',
                sort_direction: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.sort_direction) || '',
            });
        });
    }
    /**
     * Get a count of all destinations for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {DestinationFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    GetDestinationsCount(conditions, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`destination/count`, 'POST', {
                conditions,
                metadata,
            });
        });
    }
    /**
     * Create a new destination to receive bsv with and return that destination
     *
     * This function allows you to create a destination that will be monitored on-chain and will import any transactions
     * related to that destination into SPV Wallet. This is legacy functionality in Bitcoin and should only be used if a p2p
     * option (paymail) is not possible. Use sparingly.
     *
     * @param {Metadata} metadata Key value object to attach to the new destination
     * @return {Destination}
     */
    NewDestination(metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`destination`, 'POST', { metadata });
        });
    }
    /**
     * Updated the metadata object of the destination given by ID with new keys (does not overwrite the old object)
     *
     * To remove a key from the metadata object, add a key to set with a value of `null`
     *
     * @param {string} id Database ID of the destination
     * @param {Metadata} metadata Key value object to append to the metadata of the destination
     * @return {Destination}
     */
    UpdateDestinationMetadataByID(id, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`destination`, 'PATCH', {
                id,
                metadata,
            });
        });
    }
    /**
     * Updated the metadata object of the destination given by locking script with new keys (does not overwrite the old object)
     *
     * To remove a key from the metadata object, add a key to set with a value of `null`
     *
     * @param {string} locking_script Locking script of the destination
     * @param {Metadata} metadata Key value object to append to the metadata of the destination
     * @return {Destination}
     */
    UpdateDestinationMetadataByLockingScript(locking_script, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`destination`, 'PATCH', {
                locking_script,
                metadata,
            });
        });
    }
    /**
     * Updated the metadata object of the destination given by address with new keys (does not overwrite the old object)
     *
     * To remove a key from the metadata object, add a key to set with a value of `null`
     *
     * @param {string} address Address of the destination
     * @param {Metadata} metadata Key value object to append to the metadata of the destination
     * @return {Destination}
     */
    UpdateDestinationMetadataByAddress(address, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`destination`, 'PATCH', {
                address,
                metadata,
            });
        });
    }
    /**
     * Get a list of all contacts for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {ContactFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} queryParams Database query parameters for page, page size and sorting
     * @return {Contacts}
     */
    GetContacts(conditions, metadata, queryParams) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`contact/search`, 'POST', {
                conditions,
                metadata,
                page: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.page) || 0,
                page_size: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.page_size) || 0,
                order_by_field: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.order_by_field) || '',
                sort_direction: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.sort_direction) || '',
            });
        });
    }
    /**
     * Upsert will add a new contact or modify an existing one.
     *
     * @param {string} paymail            Contact paymail to add or modify
     * @param {string} fullName           Full name of the contact which could be shown instead of whole paymail address.
     * @param {string} requesterPaymail   Paymail of the requester
     * @param {Metadata} metadata         Key value object to use to filter the documents by the metadata
     * @return {Contact}
     */
    UpsertContact(paymail, fullName, requesterPaymail, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let payload = { fullName, requesterPaymail, metadata };
            if (requesterPaymail !== '') {
                payload['requesterPaymail'] = requesterPaymail;
            }
            return yield this.http.request(`contact/${paymail}`, 'PUT', payload);
        });
    }
    /**
     * Accept a contact request
     *
     * @param {string} paymail Contact paymail to modify
     * @return {void}
     */
    AcceptContact(paymail) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`contact/accepted/${paymail}`, 'PATCH');
        });
    }
    /**
     * Reject a contact request
     *
     * @param {string} paymail Contact paymail to modify
     * @return {void}
     */
    RejectContact(paymail) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`contact/rejected/${paymail}`, 'PATCH');
        });
    }
    /**
     * Confirm a contact request
     *
     * @param {string} passcode - The passcode for the contact
     * @param contact
     * @param {string} paymail Contact paymail
     * @param {number} period - The period for the TOTP
     * @param {number} digits - The number of digits for the TOTP
     * @returns {Promise<void>}
     * @throws {ErrorWrongTOTP} If the TOTP is invalid
     * @throws {ErrorNoXPrivToValidateTOTP} If the xPriv is not set
     */
    ConfirmContact(passcode, contact, paymail, period, digits) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const isTotpValid = this.ValidateTotpForContact(contact, passcode, paymail, period, digits);
            if (!isTotpValid) {
                throw new ErrorWrongTOTP();
            }
            return yield this.http.request(`contact/confirmed/${paymail}`, 'PATCH');
        });
    }
    /**
     * Get all details of the transaction by the given ID
     *
     * @param {string} txID Transaction ID
     * @return {Tx}
     */
    GetTransaction(txID) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`transaction?id=${txID}`, 'GET');
        });
    }
    /**
     * Get a list of all transactions for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {TransactionFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} queryParams Database query parameters for page, page size and sorting
     * @return {Txs}
     */
    GetTransactions(conditions, metadata, queryParams) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`transaction/search`, 'POST', {
                conditions,
                metadata,
                page: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.page) || 0,
                page_size: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.page_size) || 0,
                order_by_field: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.order_by_field) || '',
                sort_direction: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.sort_direction) || '',
            });
        });
    }
    /**
     * Get a count of all transactions for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {TransactionFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    GetTransactionsCount(conditions, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`transaction/count`, 'POST', {
                conditions,
                metadata,
            });
        });
    }
    /**
     * Get all details of the utxo by the given ID
     *
     * @param {string} tx_id Transaction ID of the UTXO
     * @param {number} output_index Index of output within the transaction of the UTXO
     * @return {Utxo}
     */
    GetUtxo(tx_id, output_index) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`utxo?tx_id=${tx_id}&output_index=${output_index}`);
        });
    }
    /**
     * Get a list of all utxos for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {UtxoFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} queryParams Database query parameters for page, page size and sorting
     * @return {Utxos}
     */
    GetUtxos(conditions, metadata, queryParams) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`utxo/search`, 'POST', {
                conditions,
                metadata,
                page: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.page) || 0,
                page_size: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.page_size) || 0,
                order_by_field: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.order_by_field) || '',
                sort_direction: (queryParams === null || queryParams === void 0 ? void 0 : queryParams.sort_direction) || '',
            });
        });
    }
    /**
     * Get a count of all utxos for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {UtxoFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    GetUtxosCount(conditions, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`utxo/count`, 'POST', {
                conditions,
                metadata,
            });
        });
    }
    /**
     * Create a draft transaction to the recipients given
     *
     * This is a helper function to easily create a new draft transaction to a list of recipients
     *
     * @see {@link SendToRecipients}
     * @param {Recipients} recipients A list of recipients and a satoshi value to send to them
     * @param {Metadata} metadata     Key value object to use to add to the draft transaction
     * @return {DraftTx}     Complete draft transaction object from SPV Wallet, all configuration options filled in
     */
    DraftToRecipients(recipients, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const transactionConfig = {
                outputs: recipients,
            };
            return yield this.http.request(`transaction`, 'POST', {
                config: transactionConfig,
                metadata,
            });
        });
    }
    /**
     * Create a draft transaction using the given transaction config
     *
     * @param {TransactionConfigInput} transactionConfig Configuration of the new transaction
     * @param {Metadata} metadata                        Key value object to use to add to the draft transaction
     * @return {DraftTx}                        Complete draft transaction object from SPV Wallet, all configuration options filled in
     */
    DraftTransaction(transactionConfig, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`transaction`, 'POST', {
                config: transactionConfig,
                metadata,
            });
        });
    }
    /**
     * Helper function to create a draft, sign it and send it to a list of recipients
     *
     * @param {Recipients} recipients A list of recipients and a satoshi value to send to them
     * @param {Metadata} metadata     Key value object to use to add to the (draft) transaction
     * @return {Tx}          The final transaction object, including the hex of the Bitcoin transaction
     * @example
     * // This function is a shorthand for:
     * const draft = await spvWalletClient.DraftToRecipients(recipients, metadata);
     * const finalized = await spvWalletClient.SignTransaction(draft);
     * const tx = await spvWalletClient.RecordTransaction(finalized, draft.id, metadata)
     */
    SendToRecipients(recipients, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const draft = yield this.DraftToRecipients(recipients, metadata);
            const finalized = yield this.SignTransaction(draft);
            return this.RecordTransaction(finalized, draft.id, metadata);
        });
    }
    /**
     * Finalize and sign the given draft transaction
     *
     * @param {DraftTx} draftTransaction Draft transaction object
     * @return {string} Final transaction hex
     */
    SignTransaction(draftTransaction) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!this.xPriv) {
                throw new ErrorNoXPrivToSignTransaction();
            }
            const xPriv = this.xPriv;
            const txDraft = sdk.Transaction.fromHex(draftTransaction.hex);
            (_a = draftTransaction.configuration.inputs) === null || _a === void 0 ? void 0 : _a.forEach((input, index) => {
                const { destination } = input;
                if (destination == null) {
                    throw new Error('Unexpected input that does not contain destination which is required for signing');
                }
                // derive private key (m/chain/num)
                let hdWallet = xPriv.deriveChild(destination.chain).deriveChild(destination.num);
                if (destination.paymail_external_derivation_num != null) {
                    // derive private key (m/chain/num/paymail_num)
                    hdWallet = hdWallet.deriveChild(destination.paymail_external_derivation_num);
                }
                // small sanity check for the inputs
                if (input.transaction_id != txDraft.inputs[index].sourceTXID ||
                    input.output_index != txDraft.inputs[index].sourceOutputIndex) {
                    throw new ErrorTxIdsDontMatchToDraft(this.logger, input, index, txDraft.inputs[index]);
                }
                txDraft.inputs[index].unlockingScriptTemplate = new sdk.P2PKH().unlock(hdWallet.privKey, 'single', false, input.satoshis, new sdk.P2PKH().lock(destination.address));
                txDraft.inputs[index].sourceOutputIndex = input.output_index;
                txDraft.inputs[index].sourceTXID = input.transaction_id;
            });
            yield txDraft.sign();
            return txDraft.toHex();
        });
    }
    /**
     * Record a Bitcoin transaction (in hex) into SPV Wallet
     *
     * This will only work of an input or output of the transaction can be related to an SPV Wallet user. SPV Wallet does not record
     * unrelated transaction into its database.
     *
     * @param {string} hex         Hex string of the Bitcoin transaction
     * @param {string} referenceID Optional reference ID (draft transaction ID)
     * @param {Metadata} metadata  Key value object to use to add to the transaction
     * @return {Tx}       The SPV Wallet transaction object
     */
    RecordTransaction(hex, referenceID, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`transaction/record`, 'POST', {
                hex,
                reference_id: referenceID,
                metadata,
            });
        });
    }
    /**
     * Updated the metadata object of the transaction given by txID with new keys (does not overwrite the old object)
     *
     * To remove a key from the metadata object, add a key to set with a value of `null`
     *
     * @param {string} txID       The ID of the transaction
     * @param {Metadata} metadata Key value object to use to add to the transaction
     * @return {Tx}      The complete SPV Wallet transaction object, with the new changes
     */
    UpdateTransactionMetadata(txID, metadata) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this.http.request(`transaction`, 'PATCH', {
                id: txID,
                metadata,
            });
        });
    }
    /**
     * Retrieves the shared configuration from the server.
     * @returns {SharedConfig} A promise that resolves to the shared configuration.
     */
    GetSharedConfig() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.http.hasAdminKey()) {
                return yield this.http.adminRequest(`shared-config`, 'GET');
            }
            return yield this.http.request(`shared-config`, 'GET');
        });
    }
    /**
     * Generates a TOTP for a given contact
     *
     * @param contact - The Contact
     * @param period - The TOTP period (default: 30)
     * @param digits - The number of TOTP digits (default: 2)
     * @returns The generated TOTP as a string
     */
    GenerateTotpForContact(contact, period = DEFAULT_TOTP_PERIOD, digits = DEFAULT_TOTP_DIGITS) {
        if (!this.xPrivKey) {
            throw new ErrorNoXPrivToGenerateTOTP();
        }
        return generateTotpForContact(this.xPrivKey, contact, period, digits);
    }
    /**
     * Validates a TOTP for a given contact
     *
     * @param passcode - The TOTP passcode to validate
     * @param requesterPaymail - The paymail of the requester
     * @param period - The TOTP period (default: 30)
     * @param digits - The number of TOTP digits (default: 2)
     * @returns A boolean indicating whether the TOTP is valid
     * @throws {ErrorNoXPrivToValidateTOTP} If the xPrivKey is not set
     */
    ValidateTotpForContact(contact, passcode, requesterPaymail, period = DEFAULT_TOTP_PERIOD, digits = DEFAULT_TOTP_DIGITS) {
        if (!this.xPrivKey) {
            throw new ErrorNoXPrivToValidateTOTP();
        }
        return validateTotpForContact(this.xPrivKey, contact, passcode, requesterPaymail, period, digits);
    }
}

exports.AuthAccessKey = AuthAccessKey;
exports.AuthHeader = AuthHeader;
exports.AuthHeaderHash = AuthHeaderHash;
exports.AuthHeaderNonce = AuthHeaderNonce;
exports.AuthHeaderTime = AuthHeaderTime;
exports.AuthSignature = AuthSignature;
exports.ErrorClientInitNoXpriv = ErrorClientInitNoXpriv;
exports.ErrorInvalidOptions = ErrorInvalidOptions;
exports.ErrorNoAdminKey = ErrorNoAdminKey;
exports.ErrorNoXPrivToGenerateTOTP = ErrorNoXPrivToGenerateTOTP;
exports.ErrorNoXPrivToSignTransaction = ErrorNoXPrivToSignTransaction;
exports.ErrorNoXPrivToValidateTOTP = ErrorNoXPrivToValidateTOTP;
exports.ErrorResponse = ErrorResponse;
exports.ErrorTxIdsDontMatchToDraft = ErrorTxIdsDontMatchToDraft;
exports.ErrorWrongHex = ErrorWrongHex;
exports.ErrorWrongTOTP = ErrorWrongTOTP;
exports.SpvWalletClient = SpvWalletClient;
exports.SpvWalletError = SpvWalletError;
exports.createSignature = createSignature;
exports.deriveChildKeyFromHex = deriveChildKeyFromHex;
exports.deriveHDChildKeyFromHex = deriveHDChildKeyFromHex;
exports.generateKeys = generateKeys;
exports.getKeysFromMnemonic = getKeysFromMnemonic;
exports.getKeysFromString = getKeysFromString;
exports.getSigningMessage = getSigningMessage;
exports.setSignature = setSignature;
//# sourceMappingURL=typescript-npm-package.cjs.js.map
