import { HD, PrivateKey, TransactionInput } from '@bsv/sdk';

interface Client {
    server_url: string;
}
/**
 * Page interface
 *
 * Holds information about the pagination state
 */
interface Page {
    number: number;
    size: number;
    totalPages: number;
    totalElements: number;
    sortDirection: string;
    orderByField: string;
}
/**
 * Paged response interface
 *
 * Holds the content and page information
 */
interface PagedResponse<T> {
    content: Array<T>;
    page: Page;
}
/**
 * Database key value conditions to filter on the metadata object
 *
 * @example
 * const metadata = {
 *   spvWalletVersion: "v0.1.3",
 *   someKey: "some value"
 * }
 */
interface Metadata {
    /**
     * Key value element
     */
    [key: string]: any;
}
/**
 * Xpub interface
 *
 * @example
 * {
    "_id": "7406ab7d9e781685d6d0ceb319b84b332ff1b773ff0bbce1671d843d50c9532a",
    "created_at": new Date(1645796112916),
    "metadata": [
      {
        "k": "user_agent",
        "v": "SpvWalletClient v1.0.0"
      },
    ],
    "current_balance": 99848517,
    "next_internal_num": 100,
    "next_external_num": 229
  }
 */
interface XPub {
    /**
     * metadata object
     */
    metadata?: Metadata;
    /**
     * xpub id
     */
    id: string;
    /**
     * Current balance in sats of the xpub
     */
    current_balance: number;
    /**
     * Next internal (change address) number to use for a new destination
     *
     * NOTE: Do not use this to create new destinations, always let SPV Wallet create the destination
     */
    next_internal_num: number;
    /**
     * Next external number to use for a new destination
     *
     * NOTE: Do not use this to create new destinations, always let SPV Wallet create the destination
     */
    next_external_num: number;
    /**
     * Date when this object was created
     */
    created_at?: Date;
    /**
     * Date when this object was last updated
     */
    updated_at?: Date;
    /**
     * If this object has been deleted, this date will be set
     */
    deleted_at?: Date;
}
/**
 * Array of xpubs
 * @see {@link XPub}
 */
interface XPubs extends Array<XPub> {
}
/**
 * Access key interface.
 *
 * This does not include the private access key, which is only given out on creation
 */
interface AccessKey {
    /**
     * ID of the access key
     */
    id: string;
    /**
     * Xpub ID this access key was created for
     */
    xpub_id: string;
    /**
     * Private access key, only given out on creation
     */
    key?: string;
    /**
     * Metadata object
     */
    metadata?: Metadata;
    /**
     * Date when this object was created
     */
    created_at: Date;
    /**
     * Date when this object was last updated
     */
    updated_at?: Date;
    /**
     * If this object has been deleted, this date will be set
     */
    deleted_at?: Date;
    /**
     * If this access key has been revoked, this date will be set and the access key will not work anymore
     */
    revoked_at?: Date;
}
/**
 * Array of access keys
 * @see {@link AccessKey}
 */
interface AccessKeys extends Array<AccessKey> {
}
interface Contact {
    /**
     * ID of the contact
     */
    id: string;
    /**
     * Full name is name which could be shown instead of whole paymail address.
     */
    fullName: string;
    /**
     * Paymail related to contact
     */
    paymail: string;
    /**
     * Public key is a public key related to contact (receiver)
     */
    pubKey: string;
    /**
     * Status is a contact's current status.
     */
    status: string;
    /**
     * Date when this object was created
     */
    created_at: Date;
    /**
     * Date when this object was last updated
     */
    updated_at?: Date;
    /**
     * If this object has been deleted, this date will be set
     */
    deleted_at?: Date;
    /**
     * Metadata object
     */
    metadata?: Metadata;
}
/**
 * Array of contacts
 * @see {@link Contact}
 */
interface Contacts extends PagedResponse<Contact> {
}
/**
 * Destination interface
 */
interface Destination {
    /**
     * ID of the destination
     */
    id: string;
    /**
     * Xpub ID this destination was created for
     */
    xpub_id: string;
    /**
     * Locking script (script pub key) of the destination
     */
    locking_script: string;
    /**
     * Type of destination: pubkeyhash, nulldata (op return), multisig, nonstandard, scripthash (deprecated p2sh), metanet, token_stas
     */
    type: string;
    /**
     * Chain num (0 = external, 1 = internal)
     */
    chain: number;
    /**
     * Num used for the derivation of the destination
     */
    num: number;
    /**
     * Paymail derivation number used for the derivation of the destination
     */
    paymail_external_derivation_num?: number;
    /**
     * Address of the destination, empty of not p2pkh
     */
    address: string;
    /**
     * ID of the draft transaction associated with this destination
     */
    draft_id: string;
    /**
     * Metadata object
     */
    metadata: Metadata;
    /**
     * Date when this object was created
     */
    created_at: Date;
    /**
     * Date when this object was last updated
     */
    updated_at?: Date;
    /**
     * If this object has been deleted, this date will be set
     */
    deleted_at?: Date;
}
/**
 * Array of destinations
 * @see {@link Destination}
 */
interface Destinations extends Array<Destination> {
}
/**
 * Tx
 */
interface Tx {
    id: string;
    hex: string;
    block_hash: string;
    block_height: number;
    fee: number;
    number_of_inputs: number;
    number_of_outputs: number;
    output_value: number;
    total_value: number;
    metadata?: Metadata;
    direction: string;
    created_at: Date;
    updated_at?: Date;
    deleted_at?: Date;
}
/**
 * Array of transactions
 * @see {@link Tx}
 */
interface Txs extends Array<Tx> {
}
/**
 * MAP protocol definition
 */
interface MapProtocol {
    /**
     * App name
     */
    app?: string;
    /**
     * Type of MAP action
     */
    type?: string;
    /**
     * MAP key value pairs
     */
    keys?: {
        [key: string]: any;
    };
}
/**
 * OP_RETURN data, only one of the attributes should be set
 */
interface OpReturn {
    /**
     * HEX string of OP_RETURN
     */
    hex?: string;
    /**
     * Array of parts of the OP_RETURN in hex
     */
    hex_parts?: string[];
    /**
     * MAP protocol definition
     * @see {@link Map}
     */
    map?: MapProtocol;
    /**
     * String parts array
     */
    string_parts?: string[];
}
/**
 * Recipient interface
 */
interface Recipient {
    to: string;
    satoshis: number;
    op_return?: OpReturn;
}
/**
 * Array of Recipients
 * @see {@link Recipient}
 */
interface Recipients extends Array<Recipient> {
}
/**
 * Fee unit to use when calculating the fee for the transaction (satoshis per byte)
 */
interface FeeUnit {
    /**
     * Satoshis
     */
    satoshis: number;
    /**
     * Bytes
     */
    bytes: number;
}
/**
 * A record pointing to a UTXO by transaction ID and output index
 */
interface UtxoPointer {
    /**
     * Transaction ID
     */
    transaction_id: string;
    /**
     * Output index
     */
    output_index: number;
}
/**
 * Transaction used as an input in a draft transaction
 */
interface TxInput {
    created_at?: Date;
    updated_at?: Date;
    metadata?: Metadata;
    deleted_at?: Date;
    id?: string;
    transaction_id: string;
    xpub_id?: string;
    output_index: number;
    satoshis: number;
    script_pub_key: string;
    type: string;
    draft_id?: string;
    reserved_at?: Date;
    spending_tx_id?: string;
    destination?: Destination;
}
/**
 * Paymail address interface
 */
interface PaymailAddress {
    id: string;
    xpub_id: string;
    alias: string;
    domain: string;
    public_name: string;
    avatar: string;
    created_at: Date;
    updated_at?: Date;
    deleted_at?: Date;
}
/**
 * Array of Paymail addresses
 * @see {@link PaymailAddress}
 */
interface PaymailAddresses extends Array<PaymailAddress> {
}
/**
 * Paymail p2p record for communicating with other p2p providers
 */
interface PaymailP4 {
    alias: string;
    domain: string;
    from_paymail?: string;
    note?: string;
    pub_key?: string;
    receive_endpoint?: string;
    reference_id?: string;
    resolution_type: string;
}
/**
 * Script output of a transaction
 */
interface ScriptOutput {
    address?: string;
    satoshis?: number;
    script: string;
    script_type?: string;
}
/**
 * Transaction output record in a draft transaction
 */
interface TxOutput {
    paymail_p4?: PaymailP4;
    satoshis?: number;
    script?: string;
    scripts?: ScriptOutput[];
    to?: string;
    op_return?: OpReturn;
}
/**
 * Configuration for syncing transaction on-chain
 */
interface SyncConfig {
    broadcast: boolean;
    broadcast_instant: boolean;
    sync_on_chain: boolean;
    paymail_p2p: boolean;
}
/**
 * Configuration for a new transaction
 */
interface TxConfig {
    change_destinations?: Destination[];
    change_destinations_strategy?: ChangeStrategy;
    change_minimum_satoshis?: number;
    change_number_of_destinations?: number;
    change_satoshis?: number;
    expires_in?: number;
    fee?: number;
    fee_unit?: FeeUnit;
    from_utxos?: UtxoPointer[];
    include_utxos?: UtxoPointer[];
    inputs?: TxInput[];
    miner?: string;
    outputs: TxOutput[];
    send_all_to?: string;
    sync?: SyncConfig;
}
/**
 * Transaction input in a new transaction
 */
interface TransactionConfigInput {
    change_destinations?: Destination[];
    change_destinations_strategy?: ChangeStrategy;
    change_minimum_satoshis?: number;
    change_number_of_destinations?: number;
    change_satoshis?: number;
    expires_in?: number;
    fee?: number;
    fee_unit?: FeeUnit;
    from_utxos?: UtxoPointer[];
    miner?: string;
    outputs: TxOutput[];
    send_all_to?: string;
    sync?: SyncConfig;
}
/**
 * Strategy to use for the change of a transaction
 */
type ChangeStrategy = 'default' | 'random' | 'nominations';
/**
 * Status of a draft transaction
 */
type DraftStatus = 'draft' | 'canceled' | 'expired' | 'complete';
/**
 * Draft transaction interface
 */
interface DraftTx {
    id: string;
    hex: string;
    metadata?: Metadata;
    xpub_id: string;
    expires_at: Date;
    configuration: TxConfig;
    status: DraftStatus;
    final_tx_id?: string;
    created_at: Date;
    updated_at?: Date;
    deleted_at?: Date;
}
/**
 * Utxo interface
 */
interface Utxo {
    id: string;
    xpub_id: string;
    satoshis: number;
    script_pub_key: string;
    type: string;
    draft_id?: string;
    reserved_at?: Date;
    spending_tx_id?: string;
    transaction?: Tx;
    created_at: Date;
    updated_at?: Date;
    deleted_at?: Date;
}
/**
 * Array of utxos
 * @see {@link Utxo}
 */
interface Utxos extends Array<Utxo> {
}
/**
 * Admin stats interface
 */
interface AdminStats {
    /**
     * Total balance of all outputs in sats in the database
     */
    balance: number;
    /**
     * Number of destinations in the database
     */
    destinations: number;
    /**
     * Number of transactions in the database
     */
    transactions: number;
    /**
     * Number of paymail addresses in the database
     */
    paymail_addresses: number;
    /**
     * Number of utxos in the database
     */
    utxos: number;
    /**
     * Number of xpubs registered in the database
     */
    xpubs: number;
    /**
     * A key value object of dates and number of transactions on that date (YYYYMMDD)
     */
    transactions_per_day: {
        [key: string]: any;
    };
    /**
     * Number of utxos per output type
     */
    utxos_per_type: {
        [key: string]: any;
    };
}
/**
 * Key basic information
 */
interface Key {
    xPriv(): string;
    xPub: PubKey;
}
/**
 * Extends Key interface with mnemonic information
 */
interface KeyWithMnemonic extends Key {
    mnemonic: string;
}
/**
 * Public key information
 */
interface PubKey {
    toString(): string;
}
interface AdminKey {
    /**
     * adminKey is used for signing admin requests.
     * Regardless of the signing method, the adminKey is required for admin requests.
     * It will not work for non-admin requests - to use them, provide xPub, xPriv or accessKey.
     */
    adminKey: string;
}
interface OptionalAdminKey extends Partial<AdminKey> {
}
interface XpubWithoutSigning extends OptionalAdminKey {
    /**
     * With xPub you can make non-admin requests without signing.
     * The SendToRecipients function will not work because it requires the xPriv.
     */
    xPub: string;
}
interface XprivWithSigning extends OptionalAdminKey {
    /**
     * xPriv is used for signing non-admin requests.
     */
    xPriv: string;
}
interface AccessKeyWithSigning extends OptionalAdminKey {
    /**
     * accessKey is used for signing non-admin requests.
     * If you want to use SendToRecipients function, you have to provide the xPriv.
     */
    accessKey: string;
}
type ClientOptions = XpubWithoutSigning | XprivWithSigning | AccessKeyWithSigning | AdminKey;
/**
 * Client options for instantiating a new SPV Wallet client
 */
/**
 * Query params to limit and order database list results
 */
interface QueryParams {
    /**
     * Page number to return (1 is first page)
     */
    page?: number;
    /**
     * Number of items to return per page
     */
    page_size?: number;
    /**
     * Order the results by this field
     */
    order_by_field?: string;
    /**
     * Sort order (desc, asc)
     */
    sort_direction?: string;
}
/**
 * SharedConfig is an interface that defines the configuration shared by different parts of the application.
 */
interface SharedConfig {
    /**
     * PaymailDomains is an array of strings representing the allowed Paymail domains.
     */
    paymail_domains: string[];
    /**
     * ExperimentalFeatures is a map of experimental features handled by spv-wallet.
     * The keys are strings representing the feature names, and the values are booleans representing whether the feature is enabled or not.
     */
    experimental_features: {
        [key: string]: boolean;
    };
}
type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS' | 'CONNECT' | 'TRACE';

declare const deriveChildKeyFromHex: (hdKey: HD, hexHash: string) => HD;
declare const deriveHDChildKeyFromHex: (hdKey: HD, hexHash: string) => HD;
declare const generateKeys: () => KeyWithMnemonic;
declare const getKeysFromMnemonic: (mnemonicStr: string) => KeyWithMnemonic;
declare const getKeysFromString: (privateKey: string) => Key;

interface Logger {
    debug(msg: string, ...args: any[]): void;
    info(msg: string, ...args: any[]): void;
    warn(msg: string, ...args: any[]): void;
    error(msg: string, ...args: any[]): void;
}
interface ConsoleLoggerLevel {
    level: 'debug' | 'info' | 'warn' | 'error' | 'disabled';
}
type LoggerConfig = Logger | ConsoleLoggerLevel;

declare class HttpClient {
    private logger;
    private adminKey?;
    private signingKey?;
    private xPubString?;
    private baseUrl;
    constructor(logger: Logger, url: string, key?: string | HD | PrivateKey, adminKey?: string);
    adminRequest(path: string, method?: HttpMethod, payload?: any): Promise<any>;
    request(path: string, method?: HttpMethod, payload?: any): Promise<any>;
    hasAdminKey(): boolean;
    private makeRequest;
    private prepareUrl;
}

interface TimeRange {
    from?: string;
    to?: string;
}
interface ModelFilter {
    includeDeleted?: boolean;
    createdRange?: TimeRange;
    updatedRange?: TimeRange;
}
interface AccessKeyFilter extends ModelFilter {
    revokedRange?: TimeRange;
}
interface AdminAccessKeyFilter extends AccessKeyFilter {
    xpubId?: string;
}
type ContactStatus = 'unconfirmed' | 'awaiting' | 'confirmed' | 'rejected';
interface ContactFilter extends ModelFilter {
    id?: string;
    fullName?: string;
    paymail?: string;
    pubKey?: string;
    status?: ContactStatus;
}
interface DestinationFilter extends ModelFilter {
    lockingScript?: string;
    address?: string;
    draftId?: string;
}
interface AdminPaymailFilter extends ModelFilter {
    id?: string;
    xpubId?: string;
    alias?: string;
    domain?: string;
    publicName?: string;
}
type TransactionStatus = 'UNKNOWN' | 'QUEUED' | 'RECEIVED' | 'STORED' | 'ANNOUNCED_TO_NETWORK' | 'REQUESTED_BY_NETWORK' | 'SENT_TO_NETWORK' | 'ACCEPTED_BY_NETWORK' | 'SEEN_ON_NETWORK' | 'MINED' | 'SEEN_IN_ORPHAN_MEMPOOL' | 'CONFIRMED' | 'REJECTED';
interface TransactionFilter extends ModelFilter {
    hex?: string;
    blockHash?: string;
    blockHeight?: number;
    fee?: number;
    numberOfInputs?: number;
    numberOfOutputs?: number;
    draftId?: string;
    totalValue?: number;
    status?: TransactionStatus | string;
}
type UtxoType = 'pubkey' | 'pubkeyhash' | 'nulldata' | 'multisig' | 'nonstandard' | 'scripthash' | 'metanet' | 'token_stas' | 'token_sensible';
interface UtxoFilter extends ModelFilter {
    transactionId?: string;
    outputIndex?: number;
    id?: string;
    satoshis?: number;
    scriptPubKey?: string;
    type?: UtxoType;
    draftId?: string;
    reservedRange?: TimeRange;
    spendingTxId?: string;
}
interface AdminUtxoFilter extends UtxoFilter {
    xpubId?: string;
}
interface XpubFilter extends ModelFilter {
    id?: string;
    currentBalance?: number;
}

/**
 * SpvWallet class
 *
 * @constructor
 * @example
 * const SpvWalletClient = new SpvWalletClient(<serverUrl>, {
 *   xPriv: <xpriv...>
 * })
 */
declare class SpvWalletClient {
    logger: Logger;
    http: HttpClient;
    private xPriv?;
    constructor(serverUrl: string, options: XpubWithoutSigning, loggerConfig?: LoggerConfig);
    constructor(serverUrl: string, options: AccessKeyWithSigning, loggerConfig?: LoggerConfig);
    constructor(serverUrl: string, options: XprivWithSigning, loggerConfig?: LoggerConfig);
    constructor(serverUrl: string, options: AdminKey, loggerConfig?: LoggerConfig);
    get xPrivKey(): HD | undefined;
    private makeRequester;
    /**
     * Admin only: Return whether the admin key is valid on the server
     *
     * @return {boolean}
     */
    AdminGetStatus(): Promise<boolean>;
    /**
     * Admin only: Get stats about the SPV Wallet server
     *
     * @return {AdminStats}
     */
    AdminGetStats(): Promise<AdminStats>;
    /**
     * Admin only: Get a list of all access keys in the system, filtered by conditions, metadata and queryParams
     *
     * @param {AdminAccessKeyFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {AccessKeys}
     */
    AdminGetAccessKeys(conditions: AdminAccessKeyFilter, metadata: Metadata, params: QueryParams): Promise<AccessKeys>;
    /**
     * Admin only: Get a count of all access keys in the system, filtered by conditions, metadata and queryParams
     *
     * @param {AdminAccessKeyFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    AdminGetAccessKeysCount(conditions: AdminAccessKeyFilter, metadata: Metadata): Promise<number>;
    /**
     * Admin only: Get a list of all contacts in the system, filtered by conditions, metadata and queryParams
     *
     * @param {ContactFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {Contacts}
     */
    AdminGetContacts(conditions: ContactFilter, metadata: Metadata, params: QueryParams): Promise<Contacts>;
    /**
     * Admin only: Update contact fullName and metadata
     *
     * @param {string} id              Contact ID to update
     * @param {string} fullName        New full name of the contact
     * @param {Metadata} metadata      Key value object to use to filter the documents by the metadata
     * @constructor
     */
    AdminUpdateContact(id: string, fullName: string, metadata: Metadata): Promise<Contact>;
    /**
     * Admin only: Delete a contact
     *
     * @param {string} id Contact ID to delete
     * @return void
     */
    AdminDeleteContact(id: string): Promise<void>;
    /**
     * Admin only: Accept a contact request
     *
     * @param {string} id Contact ID to accept
     * @return {Contact}
     */
    AdminAcceptContact(id: string): Promise<Contact>;
    /**
     * Admin only: Reject a contact request
     *
     * @param {string} id Contact ID to reject
     * @return {Contact}
     */
    AdminRejectContact(id: string): Promise<Contact>;
    /**
     * Admin only: Get a list of all destinations in the system, filtered by conditions, metadata and queryParams
     *
     * @param {DestinationFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {Destinations}
     */
    AdminGetDestinations(conditions: DestinationFilter, metadata: Metadata, params: QueryParams): Promise<Destinations>;
    /**
     * Admin only: Get a count of all destinations in the system, filtered by conditions, metadata and queryParams
     *
     * @param {DestinationFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    AdminGetDestinationsCount(conditions: DestinationFilter, metadata: Metadata): Promise<number>;
    /**
     * Admin only: Get a paymail by address
     *
     * @param address string Paymail address (i.e. alias@example.com)
     * @return {PaymailAddress}
     */
    AdminGetPaymail(address: string): Promise<PaymailAddress>;
    /**
     * Admin only: Get a list of all paymails in the system, filtered by conditions, metadata and queryParams
     *
     * @param {AdminPaymailFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {PaymailAddresses}
     */
    AdminGetPaymails(conditions: AdminPaymailFilter, metadata: Metadata, params: QueryParams): Promise<PaymailAddresses>;
    /**
     * Admin only: Get a count of all paymails in the system, filtered by conditions, metadata and queryParams
     * To get a count of not-deleted paymails, use the condition: { deleted_at: null }
     *
     * @param {AdminPaymailFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    AdminGetPaymailsCount(conditions: AdminPaymailFilter, metadata: Metadata): Promise<number>;
    /**
     * Admin only: Create a new paymail for an xPub
     *
     * @param {string} rawXPub Raw xPub to register the paymail to
     * @param {string} address Paymail address (i.e. alias@example.com)
     * @param {string} public_name Public name for the user to return in Paymail address resolution requests
     * @param {string} avatar Avatar of the user to return in Paymail address resolution requests
     * @return {PaymailAddress}
     */
    AdminCreatePaymail(rawXPub: string, address: string, public_name: string, avatar: string): Promise<PaymailAddress>;
    /**
     * Admin only: Delete a paymail
     *
     * @param address string Paymail address (ie. example@spv-wallet.org)
     * @return void
     */
    AdminDeletePaymail(address: string): Promise<void>;
    /**
     * Admin only: Get a list of all transactions in the system, filtered by conditions, metadata and queryParams
     *
     * @param {TransactionFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {Txs}
     */
    AdminGetTransactions(conditions: TransactionFilter, metadata: Metadata, params: QueryParams): Promise<Txs>;
    /**
     * Admin only: Get a count of all transactions in the system, filtered by conditions, metadata and queryParams
     *
     * @param {TransactionFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    AdminGetTransactionsCount(conditions: TransactionFilter, metadata: Metadata): Promise<number>;
    /**
     * Admin only: Get a list of all utxos in the system, filtered by conditions, metadata and queryParams
     *
     * @param {AdminUtxoFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {Utxos}
     */
    AdminGetUtxos(conditions: AdminUtxoFilter, metadata: Metadata, params: QueryParams): Promise<Utxos>;
    /**
     * Admin only: Get a count of all utxos in the system, filtered by conditions, metadata and queryParams
     *
     * @param {AdminUtxoFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    AdminGetUtxosCount(conditions: AdminUtxoFilter, metadata: Metadata): Promise<number>;
    /**
     * Admin only: Get a list of all xpubs in the system, filtered by conditions, metadata and queryParams
     *
     * @param {XpubFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} params Database query parameters for page, page size and sorting
     * @return {XPubs}
     */
    AdminGetXPubs(conditions: XpubFilter, metadata: Metadata, params: QueryParams): Promise<XPubs>;
    /**
     * Admin only: Get a count of all xpubs in the system, filtered by conditions, metadata and queryParams
     *
     * @param {XpubFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    AdminGetXPubsCount(conditions: XpubFilter, metadata: Metadata): Promise<number>;
    /**
     * Admin only: Register a new xPub into the SPV Wallet
     *
     * @param {string} rawXPub    XPub string
     * @param {Metadata} metadata Key value object to use to add to the xpub
     * @return {XPub}             The newly registered xpub
     */
    AdminNewXpub(rawXPub: string, metadata: Metadata): Promise<XPub>;
    /**
     * Admin only: Record a transaction without any of the normal checks
     *
     * @param {string} hex  Hex string of the transaction
     * @return {Tx}
     */
    AdminRecordTransaction(hex: string): Promise<Tx>;
    /**
     * Get information about the xpub from the server of the current user
     *
     * @return {XPub}
     */
    GetXPub(): Promise<XPub>;
    /**
     * Update the metadata of the xpub of the current user
     *
     * Admin key should be set to use this method
     *
     * @param {Metadata} metadata Key value object to use to update the metadata. To delete keys add a key with null value
     * @return {XPub}
     */
    UpdateXPubMetadata(metadata: Metadata): Promise<XPub>;
    /**
     * Get an access key by ID
     *
     * @param {string} id The database ID of the access key
     * @return {AccessKey}
     */
    GetAccessKey(id: string): Promise<AccessKey>;
    /**
     * Get a list of all access keys for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {AccessKeyFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} queryParams Database query parameters for page, page size and sorting
     * @return {AccessKeys}
     */
    GetAccessKeys(conditions: AccessKeyFilter, metadata: Metadata, queryParams: QueryParams): Promise<AccessKeys>;
    /**
     * Get a count of all access keys for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {AccessKeyFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    GetAccessKeysCount(conditions: AccessKeyFilter, metadata: Metadata): Promise<number>;
    /**
     * Create a new access key, with the (optional) metadata
     *
     * This method returns the newly created access key, with the private key, which is only given out this once
     *
     * @param metadata Metadata Metadata to add to the new access key
     * @return {AccessKey}
     */
    CreateAccessKey(metadata: Metadata): Promise<AccessKey>;
    /**
     * Revoke an access key and invalidate in the database
     *
     * After this function is successfully called, the access key cannot be used anymore on an SPV Wallet server
     *
     * @param id string The database ID of the access key to revoke
     * @return {AccessKey}
     */
    RevokeAccessKey(id: string): Promise<AccessKey>;
    /**
     * Get a destination of the current user by database ID
     *
     * @param id string Database ID of destination (sha256 hash of locking script)
     * @return {Destination}
     */
    GetDestinationByID(id: string): Promise<Destination>;
    /**
     * Get a destination of the current user by locking script
     *
     * @param locking_script string Locking script (script pub key)
     * @return {Destination}
     */
    GetDestinationByLockingScript(locking_script: string): Promise<Destination>;
    /**
     * Get a destination of the current user by bitcoin address
     *
     * @param address string Bitcoin address
     * @return {Destination}
     */
    GetDestinationByAddress(address: string): Promise<Destination>;
    /**
     * Get a list of all destinations for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {DestinationFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} queryParams Database query parameters for page, page size and sorting
     * @return {Destinations}
     */
    GetDestinations(conditions: DestinationFilter, metadata: Metadata, queryParams: QueryParams): Promise<Destinations>;
    /**
     * Get a count of all destinations for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {DestinationFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    GetDestinationsCount(conditions: DestinationFilter, metadata: Metadata): Promise<number>;
    /**
     * Create a new destination to receive bsv with and return that destination
     *
     * This function allows you to create a destination that will be monitored on-chain and will import any transactions
     * related to that destination into SPV Wallet. This is legacy functionality in Bitcoin and should only be used if a p2p
     * option (paymail) is not possible. Use sparingly.
     *
     * @param {Metadata} metadata Key value object to attach to the new destination
     * @return {Destination}
     */
    NewDestination(metadata: Metadata): Promise<Destination>;
    /**
     * Updated the metadata object of the destination given by ID with new keys (does not overwrite the old object)
     *
     * To remove a key from the metadata object, add a key to set with a value of `null`
     *
     * @param {string} id Database ID of the destination
     * @param {Metadata} metadata Key value object to append to the metadata of the destination
     * @return {Destination}
     */
    UpdateDestinationMetadataByID(id: string, metadata: Metadata): Promise<Destination>;
    /**
     * Updated the metadata object of the destination given by locking script with new keys (does not overwrite the old object)
     *
     * To remove a key from the metadata object, add a key to set with a value of `null`
     *
     * @param {string} locking_script Locking script of the destination
     * @param {Metadata} metadata Key value object to append to the metadata of the destination
     * @return {Destination}
     */
    UpdateDestinationMetadataByLockingScript(locking_script: string, metadata: Metadata): Promise<Destination>;
    /**
     * Updated the metadata object of the destination given by address with new keys (does not overwrite the old object)
     *
     * To remove a key from the metadata object, add a key to set with a value of `null`
     *
     * @param {string} address Address of the destination
     * @param {Metadata} metadata Key value object to append to the metadata of the destination
     * @return {Destination}
     */
    UpdateDestinationMetadataByAddress(address: string, metadata: Metadata): Promise<Destination>;
    /**
     * Get a list of all contacts for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {ContactFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} queryParams Database query parameters for page, page size and sorting
     * @return {Contacts}
     */
    GetContacts(conditions: ContactFilter, metadata: Metadata, queryParams: QueryParams): Promise<Contacts>;
    /**
     * Upsert will add a new contact or modify an existing one.
     *
     * @param {string} paymail            Contact paymail to add or modify
     * @param {string} fullName           Full name of the contact which could be shown instead of whole paymail address.
     * @param {string} requesterPaymail   Paymail of the requester
     * @param {Metadata} metadata         Key value object to use to filter the documents by the metadata
     * @return {Contact}
     */
    UpsertContact(paymail: string, fullName: string, requesterPaymail: string, metadata: Metadata): Promise<Contact>;
    /**
     * Accept a contact request
     *
     * @param {string} paymail Contact paymail to modify
     * @return {void}
     */
    AcceptContact(paymail: string): Promise<void>;
    /**
     * Reject a contact request
     *
     * @param {string} paymail Contact paymail to modify
     * @return {void}
     */
    RejectContact(paymail: string): Promise<void>;
    /**
     * Confirm a contact request
     *
     * @param {string} passcode - The passcode for the contact
     * @param contact
     * @param {string} paymail Contact paymail
     * @param {number} period - The period for the TOTP
     * @param {number} digits - The number of digits for the TOTP
     * @returns {Promise<void>}
     * @throws {ErrorWrongTOTP} If the TOTP is invalid
     * @throws {ErrorNoXPrivToValidateTOTP} If the xPriv is not set
     */
    ConfirmContact(passcode: string, contact: Contact, paymail: string, period: number, digits: number): Promise<boolean>;
    /**
     * Get all details of the transaction by the given ID
     *
     * @param {string} txID Transaction ID
     * @return {Tx}
     */
    GetTransaction(txID: string): Promise<Tx>;
    /**
     * Get a list of all transactions for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {TransactionFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} queryParams Database query parameters for page, page size and sorting
     * @return {Txs}
     */
    GetTransactions(conditions: TransactionFilter, metadata: Metadata, queryParams: QueryParams): Promise<Txs>;
    /**
     * Get a count of all transactions for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {TransactionFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    GetTransactionsCount(conditions: TransactionFilter, metadata: Metadata): Promise<number>;
    /**
     * Get all details of the utxo by the given ID
     *
     * @param {string} tx_id Transaction ID of the UTXO
     * @param {number} output_index Index of output within the transaction of the UTXO
     * @return {Utxo}
     */
    GetUtxo(tx_id: string, output_index: number): Promise<Utxo>;
    /**
     * Get a list of all utxos for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {UtxoFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @param {QueryParams} queryParams Database query parameters for page, page size and sorting
     * @return {Utxos}
     */
    GetUtxos(conditions: UtxoFilter, metadata: Metadata, queryParams: QueryParams): Promise<Utxos>;
    /**
     * Get a count of all utxos for the current user, filtered by conditions, metadata and queryParams
     *
     * @param {UtxoFilter} conditions   Key value object to use to filter the documents
     * @param {Metadata} metadata       Key value object to use to filter the documents by the metadata
     * @return {number}
     */
    GetUtxosCount(conditions: UtxoFilter, metadata: Metadata): Promise<number>;
    /**
     * Create a draft transaction to the recipients given
     *
     * This is a helper function to easily create a new draft transaction to a list of recipients
     *
     * @see {@link SendToRecipients}
     * @param {Recipients} recipients A list of recipients and a satoshi value to send to them
     * @param {Metadata} metadata     Key value object to use to add to the draft transaction
     * @return {DraftTx}     Complete draft transaction object from SPV Wallet, all configuration options filled in
     */
    DraftToRecipients(recipients: Recipients, metadata: Metadata): Promise<DraftTx>;
    /**
     * Create a draft transaction using the given transaction config
     *
     * @param {TransactionConfigInput} transactionConfig Configuration of the new transaction
     * @param {Metadata} metadata                        Key value object to use to add to the draft transaction
     * @return {DraftTx}                        Complete draft transaction object from SPV Wallet, all configuration options filled in
     */
    DraftTransaction(transactionConfig: TransactionConfigInput, metadata: Metadata): Promise<DraftTx>;
    /**
     * Helper function to create a draft, sign it and send it to a list of recipients
     *
     * @param {Recipients} recipients A list of recipients and a satoshi value to send to them
     * @param {Metadata} metadata     Key value object to use to add to the (draft) transaction
     * @return {Tx}          The final transaction object, including the hex of the Bitcoin transaction
     * @example
     * // This function is a shorthand for:
     * const draft = await spvWalletClient.DraftToRecipients(recipients, metadata);
     * const finalized = await spvWalletClient.SignTransaction(draft);
     * const tx = await spvWalletClient.RecordTransaction(finalized, draft.id, metadata)
     */
    SendToRecipients(recipients: Recipients, metadata: Metadata): Promise<Tx>;
    /**
     * Finalize and sign the given draft transaction
     *
     * @param {DraftTx} draftTransaction Draft transaction object
     * @return {string} Final transaction hex
     */
    SignTransaction(draftTransaction: DraftTx): Promise<string>;
    /**
     * Record a Bitcoin transaction (in hex) into SPV Wallet
     *
     * This will only work of an input or output of the transaction can be related to an SPV Wallet user. SPV Wallet does not record
     * unrelated transaction into its database.
     *
     * @param {string} hex         Hex string of the Bitcoin transaction
     * @param {string} referenceID Optional reference ID (draft transaction ID)
     * @param {Metadata} metadata  Key value object to use to add to the transaction
     * @return {Tx}       The SPV Wallet transaction object
     */
    RecordTransaction(hex: string, referenceID: string, metadata: Metadata): Promise<Tx>;
    /**
     * Updated the metadata object of the transaction given by txID with new keys (does not overwrite the old object)
     *
     * To remove a key from the metadata object, add a key to set with a value of `null`
     *
     * @param {string} txID       The ID of the transaction
     * @param {Metadata} metadata Key value object to use to add to the transaction
     * @return {Tx}      The complete SPV Wallet transaction object, with the new changes
     */
    UpdateTransactionMetadata(txID: string, metadata: Metadata): Promise<Tx>;
    /**
     * Retrieves the shared configuration from the server.
     * @returns {SharedConfig} A promise that resolves to the shared configuration.
     */
    GetSharedConfig(): Promise<SharedConfig>;
    /**
     * Generates a TOTP for a given contact
     *
     * @param contact - The Contact
     * @param period - The TOTP period (default: 30)
     * @param digits - The number of TOTP digits (default: 2)
     * @returns The generated TOTP as a string
     */
    GenerateTotpForContact(contact: Contact, period?: number, digits?: number): string;
    /**
     * Validates a TOTP for a given contact
     *
     * @param passcode - The TOTP passcode to validate
     * @param requesterPaymail - The paymail of the requester
     * @param period - The TOTP period (default: 30)
     * @param digits - The number of TOTP digits (default: 2)
     * @returns A boolean indicating whether the TOTP is valid
     * @throws {ErrorNoXPrivToValidateTOTP} If the xPrivKey is not set
     */
    ValidateTotpForContact(contact: Contact, passcode: string, requesterPaymail: string, period?: number, digits?: number): boolean;
}

interface AuthPayload {
    AuthHash?: string;
    AuthNonce?: string;
    AuthTime?: number;
    BodyContents?: string;
    Signature?: string;
    xPub?: string;
    accessKey?: string;
}
declare const AuthHeader = "x-auth-xpub";
declare const AuthAccessKey = "x-auth-key";
declare const AuthSignature = "x-auth-signature";
declare const AuthHeaderHash = "x-auth-hash";
declare const AuthHeaderNonce = "x-auth-nonce";
declare const AuthHeaderTime = "x-auth-time";
declare const setSignature: (headers: {
    [key: string]: string;
}, signingKey: HD | PrivateKey, bodyString: string) => {
    [key: string]: string;
};
declare const createSignature: (signingKey: HD | PrivateKey, bodyString: string) => AuthPayload;
declare const getSigningMessage: (xPub: string, auth: AuthPayload) => string;

declare class SpvWalletError extends Error {
    constructor(message: string);
}
declare class ErrorInvalidOptions extends SpvWalletError {
    constructor(logger: Logger, options: ClientOptions);
}
declare class ErrorNoXPrivToSignTransaction extends SpvWalletError {
    constructor();
}
declare class ErrorClientInitNoXpriv extends SpvWalletError {
    constructor();
}
declare class ErrorTxIdsDontMatchToDraft extends SpvWalletError {
    input: TxInput;
    draftInput: TransactionInput;
    constructor(logger: Logger, input: TxInput, index: number, draftInput: TransactionInput);
}
declare class ErrorNoAdminKey extends SpvWalletError {
    constructor();
}
declare class ErrorResponse extends SpvWalletError {
    response: Response;
    content: string;
    constructor(logger: Logger, response: Response, content: string);
}
declare class ErrorWrongHex extends SpvWalletError {
    value: string;
    constructor(wrongHex: string);
}
declare class ErrorNoXPrivToGenerateTOTP extends SpvWalletError {
    constructor();
}
declare class ErrorNoXPrivToValidateTOTP extends SpvWalletError {
    constructor();
}
declare class ErrorWrongTOTP extends SpvWalletError {
    constructor();
}

export { type AccessKey, type AccessKeyWithSigning, type AccessKeys, type AdminKey, type AdminStats, AuthAccessKey, AuthHeader, AuthHeaderHash, AuthHeaderNonce, AuthHeaderTime, type AuthPayload, AuthSignature, type ChangeStrategy, type Client, type ClientOptions, type Contact, type Contacts, type Destination, type Destinations, type DraftStatus, type DraftTx, ErrorClientInitNoXpriv, ErrorInvalidOptions, ErrorNoAdminKey, ErrorNoXPrivToGenerateTOTP, ErrorNoXPrivToSignTransaction, ErrorNoXPrivToValidateTOTP, ErrorResponse, ErrorTxIdsDontMatchToDraft, ErrorWrongHex, ErrorWrongTOTP, type FeeUnit, type HttpMethod, type Key, type KeyWithMnemonic, type MapProtocol, type Metadata, type OpReturn, type OptionalAdminKey, type Page, type PagedResponse, type PaymailAddress, type PaymailAddresses, type PaymailP4, type PubKey, type QueryParams, type Recipient, type Recipients, type ScriptOutput, type SharedConfig, SpvWalletClient, SpvWalletError, type SyncConfig, type TransactionConfigInput, type Tx, type TxConfig, type TxInput, type TxOutput, type Txs, type Utxo, type UtxoPointer, type Utxos, type XPub, type XPubs, type XprivWithSigning, type XpubWithoutSigning, createSignature, deriveChildKeyFromHex, deriveHDChildKeyFromHex, generateKeys, getKeysFromMnemonic, getKeysFromString, getSigningMessage, setSignature };
